import React, { useState, useEffect, useRef, useCallback } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, BarChart, Bar, AreaChart, Area, PieChart, Pie, Cell, Label, ReferenceDot } from 'recharts';
import { ChevronDown, Factory, TrendingUp, Cpu, Lightbulb, Zap, Clock, Thermometer, Droplet, Calendar, Gauge, AlertTriangle, MessageSquare, HelpCircle, Eye, Cloud, Download, CloudRain, Wind, Info, BellRing, LayoutDashboard, BarChart3, Building2, Activity, Leaf, Power, Sigma, Bolt, SlidersHorizontal, Settings, TestTube2 } from 'lucide-react';

// Placeholder for API Key (Canvas will inject if needed)
const apiKey = "";

// const plants = [
//   "Mahindra Vehicle Manufacturing Plant - Chakan",
//   "Volkswagen Chattanooga Assembly Plant",
//   "Renault Nissan Automotive India Plant",
//   "Fiat Chrysler Automobiles (FCA) Cassino Plant",
//   "Daimler AG Mercedes-Benz Sindelfingen Plant"
// ];
const processesForSelectionn = ['Paint', 'Welder', 'HVAC', 'Conveyor', 'Robotics Arms'];
// Filtered list for dropdowns, removing "Overall Plant"

const PIE_COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042'];
const COLORS = ['#8884d8', '#82ca9d', '#ffc658', '#f199e4', '#a4de6c', '#d0ed57', '#ff7300', '#d82884'];

// --- MOCK DATA ---

// Mock Database for Equipment per Process
const processEquipmentDB = {
    Paint: [
        { name: 'Electrostatic Sprayer 1', icon: Cpu },
        { name: 'Curing Oven A', icon: Thermometer },
        { name: 'Mixing Vat 3', icon: Droplet },
        { name: 'Conveyor Line P-1', icon: TrendingUp },
    ],
    Welder: [
        { name: 'Spot Welder R-5', icon: Factory },
        { name: 'Arc Welder Z-9', icon: Factory },
        { name: 'Seam Welder T-1', icon: Factory },
    ],
    HVAC: [
        { name: 'Chiller Unit 1', icon: Thermometer },
        { name: 'Air Handler 4', icon: Wind },
        { name: 'Cooling Tower 2', icon: CloudRain },
    ],
    Conveyor: [
        { name: 'Main Assembly Line', icon: TrendingUp },
        { name: 'Parts Transfer Belt', icon: TrendingUp },
        { name: 'Final Inspection Line', icon: TrendingUp },
    ],
    'Robotics Arms': [
        { name: 'Assembly Arm A1', icon: Cpu },
        { name: 'Assembly Arm A2', icon: Cpu },
        { name: 'Welding Arm W1', icon: Cpu },
        { name: 'Painting Arm P1', icon: Cpu },
    ],
};

// Generates detailed live data for processes
const generateLiveProcessData = () => {
    const processData = {};
    let totalPlantEnergy = 0;
    let totalPlantRenewable = 0;
    let totalPlantNonRenewable = 0;

    Object.keys(processEquipmentDB).forEach(processName => {
        let totalProcessEnergy = 0;
        const equipment = processEquipmentDB[processName].map(equip => {
            const voltage = parseFloat((220 + (Math.random() - 0.5) * 10).toFixed(2)); // Volts
            const current = parseFloat((15 + (Math.random() - 0.5) * 5).toFixed(2)); // Amps
            const energy = parseFloat(((voltage * current) / 1000).toFixed(3)); // kWh
            totalProcessEnergy += energy;
            return { ...equip, voltage, current, energy};
        });

        const processKey = processName.toLowerCase().replace(/ /g, '');
        const processRenewable = totalProcessEnergy * (0.3 + Math.random() * 0.4); // 30-70% renewable mix
        const processNonRenewable = Math.max(0, totalProcessEnergy - processRenewable);
        
        processData[processKey] = {
            energy: parseFloat(totalProcessEnergy.toFixed(2)),
            renewable: parseFloat(processRenewable.toFixed(2)),
            nonRenewable: parseFloat(processNonRenewable.toFixed(2)),
            equipment,
        };
        totalPlantEnergy += totalProcessEnergy;
        totalPlantRenewable += processRenewable;
        totalPlantNonRenewable += processNonRenewable;
    });
    
    return {
        ...processData,
        totalPlantEnergy: parseFloat(totalPlantEnergy.toFixed(2)),
        renewable: parseFloat(totalPlantRenewable.toFixed(2)),
        nonRenewable: parseFloat(totalPlantNonRenewable.toFixed(2)),
        renewableWind: parseFloat((totalPlantRenewable * 0.3).toFixed(2)),
        renewableSolar: parseFloat((totalPlantRenewable * 0.5).toFixed(2)),
        renewableHydro: parseFloat((totalPlantRenewable * 0.2).toFixed(2)),
    };
};

// Helper to format date for display
const formatDate = (date) => {
  const d = new Date(date);
  return d.toISOString().split('T')[0];
};

const generateHistoricalData = (startDateStr, endDateStr, systems) => {
  const data = [];
  const startDate = new Date(startDateStr);
  const endDate = new Date(endDateStr);
  const diffTime = Math.abs(endDate - startDate);
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;

  for (let i = 0; i < diffDays; i++) {
    const date = new Date(startDate);
    date.setDate(startDate.getDate() + i);
    const dayData = {
      date: date.toISOString().split('T')[0],
    };
    let totalEnergy = 0;
    systems.forEach(system => {
      const energy = parseFloat((Math.random() * 100 + 500).toFixed(2));
      dayData[system] = energy;
      totalEnergy += energy;
    });
    dayData['Total Energy'] = parseFloat(totalEnergy.toFixed(2));
    data.push(dayData);
  }
  return data;
};

const generateMonthlySummary = () => {
  const data = [];
  const systems = ['Paint', 'Welder', 'HVAC', 'Conveyor', 'Robotics Arms'];
  const currentYear = new Date().getFullYear();
  const currentMonth = new Date().getMonth(); // 0-indexed

  for (let i = 0; i <= currentMonth; i++) {
    const date = new Date(currentYear, i, 1);
    const monthName = date.toLocaleString('default', { month: 'short' });
    const year = date.getFullYear();
    const monthData = {
      month: `${monthName} ${year}`,
    };
    let totalEnergy = 0;
    systems.forEach(system => {
      const energy = parseFloat((Math.random() * 1000 + 5000).toFixed(2));
      monthData[system] = energy;
      totalEnergy += energy;
    });
    monthData['Total Energy (kWh)'] = parseFloat(totalEnergy.toFixed(2));
    data.push(monthData);
  }
  return data;
};

const generateDailyStackedData = (startDateStr, endDateStr) => {
  const data = [];
  const startDate = new Date(startDateStr);
  const endDate = new Date(endDateStr);
  const diffTime = Math.abs(endDate - startDate);
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;

  for (let i = 0; i < diffDays; i++) {
    const date = new Date(startDate);
    date.setDate(startDate.getDate() + i);
    data.push({
      date: date.toISOString().split('T')[0],
      Paint: parseFloat((Math.random() * 500 + 1000).toFixed(2)),
      Welder: parseFloat((Math.random() * 300 + 800).toFixed(2)),
      HVAC: parseFloat((Math.random() * 700 + 1500).toFixed(2)),
      Conveyor: parseFloat((Math.random() * 200 + 600).toFixed(2)),
      RoboticsArms: parseFloat((Math.random() * 400 + 1200).toFixed(2)),
    });
  }
  return data;
};

const generateTimeSeriesComparisonData = (selectedPlants, startDateStr, endDateStr) => {
  const data = [];
  const startDate = new Date(startDateStr);
  const endDate = new Date(endDateStr);
  const diffTime = Math.abs(endDate - startDate);
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;

  for (let i = 0; i < diffDays; i++) {
    const date = new Date(startDate);
    date.setDate(startDate.getDate() + i);
    const dayData = { date: date.toISOString().split('T')[0] };

    selectedPlants.forEach(plant => {
      const plantDailyData = generateLiveProcessData();
      dayData[`${plant}_totalEnergy`] = plantDailyData.totalPlantEnergy;
      dayData[`${plant}_renewable`] = plantDailyData.renewable;
      dayData[`${plant}_nonRenewable`] = plantDailyData.nonRenewable;
      
      Object.keys(processEquipmentDB).forEach(processName => {
        const processKey = processName.toLowerCase().replace(/ /g, '');
        dayData[`${plant}_${processName}`] = plantDailyData[processKey]?.energy || 0;
      });
    });
    data.push(dayData);
  }
  return data;
};


// EMISSION DATA GENERATION
// const EMISSION_FACTOR_NON_RENEWABLE_KG_PER_KWH = 0.45;
// const EMISSION_FACTOR_RENEWABLE_KG_PER_KWH = 0.02;

// const generateEmissionMetrics = (currentEnergyConsumption, renewableMixPercent) => {
//     if (isNaN(currentEnergyConsumption) || isNaN(renewableMixPercent) || currentEnergyConsumption === 0) {
//         return { totalEmissions: 0, processEmissions: [], sourceEmissions: [], emissionIntensity: 0, benchmark: 0.35 };
//     }
//     const nonRenewableEnergy = currentEnergyConsumption * (1 - (renewableMixPercent / 100));
//     const renewableEnergy = currentEnergyConsumption * (renewableMixPercent / 100);

//     const totalEmissions = (nonRenewableEnergy * EMISSION_FACTOR_NON_RENEWABLE_KG_PER_KWH) +
//                               (renewableEnergy * EMISSION_FACTOR_RENEWABLE_KG_PER_KWH);

//     const specificProcesses = processes.filter(p => p !== 'Overall Plant');
//     const processEmissions = specificProcesses.map(processName => {
//         const baseEmission = totalEmissions * (Math.random() * 0.15 + 0.05);
//         return { name: processName, emissions: parseFloat(baseEmission.toFixed(2)) };
//     });

//     const sourceEmissions = [
//         { name: 'Non-Renewable', emissions: parseFloat((nonRenewableEnergy * EMISSION_FACTOR_NON_RENEWABLE_KG_PER_KWH).toFixed(2)) },
//         { name: 'Renewable', emissions: parseFloat((renewableEnergy * EMISSION_FACTOR_RENEWABLE_KG_PER_KWH).toFixed(2)) },
//     ];

//     const emissionIntensity = parseFloat((totalEmissions / currentEnergyConsumption).toFixed(3));

//     return {
//         totalEmissions: parseFloat(totalEmissions.toFixed(2)),
//         processEmissions,
//         sourceEmissions,
//         emissionIntensity,
//         benchmark: 0.35
//     };
// };

// const generateDailyEmissions = (startDateStr, endDateStr) => {
//     const data = [];
//     const startDate = new Date(startDateStr);
//     const endDate = new Date(endDateStr);
//     const diffTime = Math.abs(endDate - startDate);
//     const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;

//     for (let i = 0; i < diffDays; i++) {
//         const date = new Date(startDate);
//         date.setDate(startDate.getDate() + i);
//         const totalConsumption = parseFloat((Math.random() * 10000 + 5000).toFixed(2));
//         const renewableMix = parseFloat((Math.random() * 30 + 50).toFixed(2));
//         const emissionsData = generateEmissionMetrics(totalConsumption, renewableMix);
//         data.push({
//             date: date.toISOString().split('T')[0],
//             totalEmissions: emissionsData.totalEmissions,
//             benchmark: emissionsData.benchmark * totalConsumption
//         });
//     }
//     return data;
// };

// --- UI COMPONENTS ---

    const CustomTooltip = ({ active, payload, label, unit = 'kWh' }) => {
    if (active && payload && payload.length) {
        return (
        <div className="p-3 bg-white border border-gray-300 rounded-lg shadow-lg text-gray-800">
            <p className="font-semibold">{label}</p>
            {payload.map((entry, index) => (
            <p key={`item-${index}`} style={{ color: entry.color }} className="text-sm">
                {`${entry.name}: ${entry.value} ${entry.unit || unit}`}
            </p>
            ))}
            {/* {payload[0].payload.isAnomaly && (
                <p className="text-red-500 text-xs mt-1">
                    ⚠️ Anomaly: {payload[0].payload.anomalyReason}
                </p>
            )} */}
        </div>
        );  
    }
    return null;
    };

const RealtimeClock = () => {
    const [time, setTime] = useState(new Date());

    useEffect(() => {
        const timerId = setInterval(() => setTime(new Date()), 1000);
        return () => clearInterval(timerId);
    }, []);

    return (
        <div className="text-right text-white">
            <p className="text-sm font-medium text-blue-200">{time.toLocaleDateString(undefined, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}</p>
            <p className="text-2xl font-bold">{time.toLocaleTimeString()}</p>
        </div>
    );
};

const Header = ({ currentPlant, setCurrentPlant }) => {
    const [plantList, setPlantList] = useState([]);

  useEffect(() => {
    fetch('https://energy-forecasting.onrender.com/api/plants')
      .then(res => res.json())
      .then(data => {
        setPlantList(data);
        setCurrentPlant(data[0]); // select first plant by default
      })
      .catch(err => console.error('Failed to load plants', err));
    }, []);

    return (
    <header className="w-full bg-gradient-to-r from-blue-600 to-indigo-800 p-4 shadow-xl sticky top-0 z-50">
        <div className="container mx-auto flex flex-col md:flex-row items-center justify-between">
            <div className="flex items-center gap-6">
                <div>
                    <h1 className="text-3xl font-extrabold text-white">VoltVisor</h1>
                    <p className="text-blue-100 text-sm font-medium mt-1">
                        AI-Powered Energy Intelligence • Predict • Optimize
                    </p>
                </div>
                <Dropdown
                    label="Plant Selector"
                    options={plantList.map(p => p.plantName)}
                    selected={currentPlant?.plantName || ''}
                    onChange={(selectedName) => {
                    const selectedPlant = plantList.find(p => p.plantName === selectedName);
                    setCurrentPlant(selectedPlant);
                    }}
                />
            </div>
            <div className="pl-4">
                <RealtimeClock />
            </div>
        </div>
    </header>
    );
};

const SectionCard = ({ title, children, className = '' }) => (
  <div className={`bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700 ${className}`}>
    <h3 className="text-xl font-semibold text-white mb-4">{title}</h3>
    {children}
  </div>
);

const Dropdown = ({ label, options, selected, onChange, isMulti = false }) => {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  const handleSelect = (option) => {
    if (isMulti) {
      const newSelection = selected.includes(option)
        ? selected.filter(item => item !== option)
        : [...selected, option];
      onChange(newSelection);
    } else {
      onChange(option);
      setIsOpen(false);
    }
  };

  return (
    <div className="relative inline-block text-left w-full md:w-auto" ref={dropdownRef}>
      <label htmlFor={label} className="sr-only">{label}</label>
      <button
        type="button"
        className="inline-flex justify-between w-full rounded-md border border-gray-600 shadow-sm px-4 py-2 bg-gray-700 text-sm font-medium text-white hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-blue-500"
        id={label}
        aria-haspopup="true"
        aria-expanded={isOpen}
        onClick={() => setIsOpen(!isOpen)}
      >
        {isMulti ? (selected.length > 0 ? selected.join(', ') : `Select ${label}`) : selected}
        <ChevronDown className="-mr-1 ml-2 h-5 w-5" aria-hidden="true" />
      </button>

      {isOpen && (
        <div
          className="origin-top-right absolute z-20 mt-2 w-full rounded-md shadow-lg bg-gray-700 ring-1 ring-black ring-opacity-5 focus:outline-none"
          role="menu"
          aria-orientation="vertical"
          aria-labelledby={label}
        >
          <div className="py-1 max-h-60 overflow-y-auto" role="none">
            {options.map((option) => (
              <label
                key={option}
                className="flex items-center px-4 py-2 text-sm text-gray-200 hover:bg-gray-600 hover:text-white cursor-pointer"
                role="menuitem"
              >
                {isMulti && (
                  <input
                    type="checkbox"
                    checked={selected.includes(option)}
                    onChange={() => handleSelect(option)}
                    className="form-checkbox h-4 w-4 text-blue-600 transition duration-150 ease-in-out bg-gray-800 border-gray-600 rounded"
                  />
                )}
                <span className={isMulti ? 'ml-2' : ''} onClick={() => !isMulti && handleSelect(option)}>{option}</span>
              </label>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

const StatCard = ({ title, value, unit, color, icon: Icon, className = '', children }) => (
  <div className={`flex flex-col p-5 rounded-xl shadow-lg border ${color} bg-opacity-10 backdrop-blur-sm ${className}`}>
    <div className="flex items-center mb-2">
      <div className={`p-3 rounded-full ${color} bg-opacity-30 mr-4`}>
        {Icon && <Icon className={`h-8 w-8 text-${color.split('-')[1]}-400`} />}
      </div>
      <div>
        <p className="text-lg font-medium text-gray-300">{title}</p>
        <p className="text-3xl font-bold text-white mt-1">{value}<span className="text-xl font-semibold text-gray-300">{unit}</span></p>
      </div>
    </div>
    {children}
  </div>
);

const DateRangePicker = ({ startDate, endDate, period, onStartDateChange, onEndDateChange, onPeriodChange }) => {
    return (
        <div className="flex flex-wrap justify-end items-center gap-2 mb-6 bg-gray-800/50 p-3 rounded-lg">
            <label className="text-gray-300 whitespace-nowrap">From:</label>
            <input type="date" value={startDate} onChange={(e) => { onStartDateChange(e.target.value); onPeriodChange('Custom'); }} className="px-3 py-2 bg-gray-700 text-white border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"/>
            <label className="text-gray-300 whitespace-nowrap">To:</label>
            <input type="date" value={endDate} onChange={(e) => { onEndDateChange(e.target.value); onPeriodChange('Custom'); }} className="px-3 py-2 bg-gray-700 text-white border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"/>
            <div className="flex space-x-1">
                {['1D', '1W', '1M'].map(p => (
                    <button key={p} onClick={() => onPeriodChange(p)} className={`px-4 py-2 rounded-lg font-medium transition-all duration-200 ${period === p ? 'bg-blue-600 text-white shadow-md' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}>{p}</button>
                ))}
            </div>
        </div>
    );
};

const MonitoringTab = ({ currentPlant }) => {
  const [activeSubTab, setActiveSubTab] = useState('Live');
  const plantId = currentPlant?.plantId; // from Header dropdown
  const [totalPlantEnergy, setTotalPlantEnergy] = useState(0);
  const [startDate, setStartDate] = useState('2025-06-01'); // default dates
  const [endDate, setEndDate] = useState('2025-06-19');
  const [processList, setProcessList] = useState([]);
    const [selectedProcess, setSelectedProcess] = useState(null);
    const [processEnergy, setProcessEnergy] = useState(0);
    const [processEmissions, setProcessEmissions] = useState(0);


  useEffect(() => {
  if (!currentPlant?.plantId) return;

  fetch(`https://energy-forecasting.onrender.com/api/plants/${plantId}`)
    .then(res => res.json())
    .then(data => {
      setProcessList(data); // directly keep it as array of process objects
      setSelectedProcess(data[0]); // default selection
    })
    .catch(err => console.error("Failed to fetch processes", err));
}, [currentPlant]);

 useEffect(() => {
  if (!currentPlant?.plantId) return;

  fetch('https://energy-forecasting.onrender.com/api/plants', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      plantId: currentPlant.plantId,
      startDate,
      endDate
    })
  })
    .then(res => res.json())
    .then(setTotalPlantEnergy)
    .catch(err => console.error('Error fetching total energy:', err));
}, [currentPlant, startDate, endDate]);

const wind = selectedProcess?.renewableEnergyPercentage?.[0] || 0;
const solar = selectedProcess?.renewableEnergyPercentage?.[1] || 0;
const hydro = selectedProcess?.renewableEnergyPercentage?.[2] || 0;



const processId = selectedProcess?.processId;


const totalRenewable = wind + solar + hydro;
const nonRenewable = 100 - totalRenewable;

useEffect(() => {
  if (!selectedProcess?.processId || !startDate || !endDate) return;

  fetch('https://energy-forecasting.onrender.com/api/processes', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      processId: selectedProcess.processId,
      startDate,
      endDate
    })
  })
    .then(res => res.json())
    .then(data => {
      setProcessEnergy(data.totalEnergyConsumedKWh);
      setProcessEmissions(data.totalCo2EmissionsKg);
    })
    .catch(err => console.error('Error fetching process energy/emissions:', err));
}, [selectedProcess, startDate, endDate]);

const [renewableBreakdown, setRenewableBreakdown] = useState({
  wind: 0,
  solar: 0,
  hydro: 0,
  total: 0,
});

useEffect(() => {
  const fetchEnergyForAllProcesses = async () => {
    if (!processList.length || !startDate || !endDate) return;

    let wind = 0, solar = 0, hydro = 0;

    for (const process of processList) {
      try {
        const res = await fetch('https://energy-forecasting.onrender.com/api/processes', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            processId: process.processId,
            startDate,
            endDate,
          }),
        });
        const data = await res.json();

        const energy = data.totalEnergyConsumedKWh || 0;
        const [w, s, h] = process.renewableEnergyPercentage || [0, 0, 0];

        wind += (w / 100) * energy;
        solar += (s / 100) * energy;
        hydro += (h / 100) * energy;

      } catch (error) {
        console.error(`Failed to fetch energy for process ${process.processName}`, error);
      }
    }

    setRenewableBreakdown({
      wind: wind.toFixed(2),
      solar: solar.toFixed(2),
      hydro: hydro.toFixed(2),
      total: (wind + solar + hydro).toFixed(2),
    });
  };

  fetchEnergyForAllProcesses();
}, [processList, startDate, endDate]);

const fetchEnergyForProcessByDate = async (processId, date) => {
  const response = await fetch('https://energy-forecasting.onrender.com/api/processes', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      processId,
      startDate: date,
      endDate: date
    })
  });
  const data = await response.json();
  return data.totalEnergyConsumedKWh || 0;
};
const [trendsStartDate, setTrendsStartDate] = useState(formatDate(new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)));
const [trendsEndDate, setTrendsEndDate] = useState(formatDate(new Date()));
const [trendsPeriod, setTrendsPeriod] = useState('1M');
const [historicalData, setHistoricalData] = useState([]);

useEffect(() => {
  const loadHistoricalData = async () => {
    if (!currentPlant || !processList.length) return;

    const start = new Date(trendsStartDate);
    const end = new Date(trendsEndDate);
    const dateArray = [];

    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
      dateArray.push(new Date(d));
    }

    const data = [];

    for (const date of dateArray) {
      const entry = { date: date.toISOString().split('T')[0] };
      let totalEnergy = 0;

      for (const process of processList) {
        const energy = await fetchEnergyForProcessByDate(process.processId, entry.date);
        entry[process.processName] = energy;
        totalEnergy += energy;
      }

      entry['Total Energy'] = parseFloat(totalEnergy.toFixed(2));
      data.push(entry);
    }

    setHistoricalData(data);
  };

  loadHistoricalData();
}, [trendsStartDate, trendsEndDate, currentPlant, processList]);

const trendLineOptions = processList.map(p => p.processName).concat('Total Energy');
const [visibleTrendLines, setVisibleTrendLines] = useState(trendLineOptions);

const [monthlySummary, setMonthlySummary] = useState([]);

useEffect(() => {
  if (!currentPlant?.plantId) return;

  const fetchMonthlySummary = async () => {
    try {
      const res = await fetch(`https://energy-forecasting.onrender.com/api/plants/monthly/${currentPlant.plantId}`);
      const data = await res.json();

      const processWise = data.processWiseMonthly;
      const plantTotals = data.plantMonthlyTotal;

      const months = Object.keys(plantTotals);

      const formatted = months.map(month => {
        const row = { month };
        Object.keys(processWise).forEach(processName => {
          row[processName] = processWise[processName][month] ?? 0;
        });
        row["Total Energy (kWh)"] = plantTotals[month];
        return row;
      });

      setMonthlySummary(formatted);
    } catch (err) {
      console.error("Failed to fetch monthly summary:", err);
    }
  };

  fetchMonthlySummary();
}, [currentPlant]);

const processesForSelection = Object.keys(monthlySummary[0] || {}).filter(k => k !== 'month' && k !== 'Total Energy (kWh)');

const [historicalEmissions, setHistoricalEmissions] = useState([]);
const [totalEmissions, setTotalEmissions] = useState(0);
const [emissionStartDate, setEmissionStartDate] = useState(formatDate(new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)));
const [emissionEndDate, setEmissionEndDate] = useState(formatDate(new Date()));
const [emissionPeriod, setEmissionPeriod] = useState('1M');

useEffect(() => {
  const fetchHistoricalEmissions = async () => {
    if (!currentPlant || !processList.length) return;

    const start = new Date(emissionStartDate);
    const end = new Date(emissionEndDate);
    const dateArray = [];

    // Generate daily date strings
    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
      dateArray.push(new Date(d));
    }

    const result = [];

    for (const date of dateArray) {
      const formattedDate = date.toISOString().split('T')[0];
      const entry = { date: formattedDate };
      let totalDayEmission = 0;

      // Fetch emissions for each process on this date
      for (const process of processList) {
        try {
          const response = await fetch('https://energy-forecasting.onrender.com/api/processes', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              processId: process.processId,
              startDate: formattedDate,
              endDate: formattedDate
            })
          });

          const data = await response.json();
          const emission = data.totalCo2EmissionsKg || 0;

          // Store process-specific emission
          entry[process.processName] = emission;
          totalDayEmission += emission;

        } catch (err) {
          console.error(`Emission fetch failed for ${process.processName} on ${formattedDate}:`, err);
        }
      }

      entry["Total Emissions (Kg)"] = parseFloat(totalDayEmission.toFixed(2));
      result.push(entry);
    }

    // Save full array and total sum
    setHistoricalEmissions(result);

    const totalSum = result.reduce((sum, day) => sum + day["Total Emissions (Kg)"], 0);
    setTotalEmissions(parseFloat(totalSum.toFixed(2)));
  };

  fetchHistoricalEmissions();
}, [currentPlant, processList, emissionStartDate, emissionEndDate]);

const renewableBreakdownData = [
  { name: 'Wind', value: parseFloat(renewableBreakdown.wind), color: '#82ca9d' },
  { name: 'Solar', value: parseFloat(renewableBreakdown.solar), color: '#fdd835' },
  { name: 'Hydro', value: parseFloat(renewableBreakdown.hydro), color: '#4fc3f7' },
  {
    name: 'Non-Renewable',
    value: Math.max(
      parseFloat(renewableBreakdown.total > 0 ? renewableBreakdown.total : 0),
      0
    ) > 0
      ? parseFloat(renewableBreakdown.total) !== 0
        ? totalPlantEnergy - parseFloat(renewableBreakdown.total)
        : 0
      : 0,
    color: '#ef5350',
  },
];

const [processSustainabilityData, setProcessSustainabilityData] = useState([]);

useEffect(() => {
  if (!processList.length) return;

  const formatted = processList.map(proc => {
    const [wind, solar, hydro] = proc.renewableEnergyPercentage || [0, 0, 0];
    const totalRenewable = wind + solar + hydro;
    const nonRenewable = 100 - totalRenewable;

    return {
      name: proc.processName,
      wind: parseFloat(wind.toFixed(2)),
      solar: parseFloat(solar.toFixed(2)),
      hydro: parseFloat(hydro.toFixed(2)),
      nonRenewable: parseFloat(nonRenewable.toFixed(2))
    };
  });

  setProcessSustainabilityData(formatted);
}, [processList]);

const [equipmentData, setEquipmentData] = useState([]);

useEffect(() => {
  const fetchEquipmentData = async () => {
    if (!selectedProcess?.processId || !startDate || !endDate) return;

    try {
      const response = await fetch('https://energy-forecasting.onrender.com/api/equipment-readings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          processId: selectedProcess?.processId,
          startDate,
          endDate,
        }),
      });

      const data = await response.json();
      const processed = data.map(e => ({
        name: e.equipmentName,
        energy: e.energyConsumedKWh,
        voltage: e.voltageAverage,
        current: e.currentAverage,
        icon: Bolt, // or customize based on equipment name if needed
      }));

      setEquipmentData(processed);
    } catch (error) {
      console.error('Error fetching equipment data:', error);
    }
  };

  fetchEquipmentData();
}, [selectedProcess?.processId, startDate, endDate]);

  const [plants, setPlants] = useState([]);
  const [plantNameToIdMap, setPlantNameToIdMap] = useState({});
  const [selectedPlantsForComparison, setSelectedPlantsForComparison] = useState([]);
  const [comparisonStartDate, setComparisonStartDate] = useState('');
  const [comparisonEndDate, setComparisonEndDate] = useState('');
  const [comparisonPeriod, setComparisonPeriod] = useState('1M');
  const [comparisonProcess, setComparisonProcess] = useState('');
  const [processesForSelectionn, setProcessesForSelectionn] = useState([]);
  const [plantComparisonData, setPlantComparisonData] = useState([]);

  useEffect(() => {
    const fetchPlants = async () => {
      try {
        const res = await fetch('https://energy-forecasting.onrender.com/api/plants');
        const data = await res.json();
        const nameIdMap = {};
        const plantNames = data.map(p => {
          nameIdMap[p.plantName] = p.plantId;
          return p.plantName;
        });
        setPlants(plantNames);
        setPlantNameToIdMap(nameIdMap);
      } catch (error) {
        console.error('Error fetching plants:', error);
      }
    };

    fetchPlants();
  }, []);

  useEffect(() => {
    const fetchComparisonData = async () => {
      if (selectedPlantsForComparison.length === 0 || !comparisonStartDate || !comparisonEndDate) return;

      const startDate = new Date(comparisonStartDate);
      const endDate = new Date(comparisonEndDate);
      const days = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;

      const newData = Array.from({ length: days }).map((_, idx) => {
        const date = new Date(startDate);
        date.setDate(startDate.getDate() + idx);
        return { date: date.toISOString().split('T')[0] };
      });

      for (const plantName of selectedPlantsForComparison) {
        const plantId = plantNameToIdMap[plantName];

        const processRes = await fetch(`https://energy-forecasting.onrender.com/api/plants/${plantId}`);
        const processes = await processRes.json();

        if (processesForSelectionn.length === 0) {
          setProcessesForSelectionn(processes.map(p => p.processName));
        }

        const selectedProc = processes.find(p => p.processName === comparisonProcess);

        for (let i = 0; i < newData.length; i++) {
          const date = newData[i].date;

          const totalRes = await fetch(`https://energy-forecasting.onrender.com/api/plants`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ plantId, startDate: date, endDate: date })
          });
          const total = await totalRes.json();
          newData[i][`${plantName}_totalEnergy`] = total.totalEnergyConsumedkWh;
          newData[i][`${plantName}_totalCO2`] = total.totalEmissionsCO2;

          if (selectedProc) {
            const procRes = await fetch(`https://energy-forecasting.onrender.com/api/processes`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ processId: selectedProc.processId, startDate: date, endDate: date })
            });
            const procData = await procRes.json();
            newData[i][`${plantName}_${comparisonProcess}`] = procData.totalEnergyConsumedkWh;
            newData[i][`${plantName}_${comparisonProcess}_CO2`] = procData.totalEmissionsCO2;
          }
        }
      }

      setPlantComparisonData(newData);
    };

    fetchComparisonData();
  }, [selectedPlantsForComparison, comparisonStartDate, comparisonEndDate, comparisonProcess]);

  const [liveStartDate, setLiveStartDate] = useState(formatDate(new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)));
  const [liveEndDate, setLiveEndDate] = useState(formatDate(new Date()));
  
  // State for date ranges
  
  const [livePeriod, setLivePeriod] = useState('1W');

  
  

  // New state for Graph section
  const [graphView, setGraphView] = useState('Energy Trends per Process');

  // const trendLineOptions = ['Total Energy', 'Paint', 'Welder', 'HVAC', 'Conveyor', 'Robotics Arms'];
  // const [visibleTrendLines, setVisibleTrendLines] = useState(trendLineOptions);
  
  const [dailyStackedData, setDailyStackedData] = useState(generateDailyStackedData(trendsStartDate, trendsEndDate));

  
  const [comparisonEnergyType, setComparisonEnergyType] = useState('Renewable');

  const [emissionData, setEmissionData] = useState(null);
  const [dailyEmissionsData, setDailyEmissionsData] = useState([]);

  // Generic handler for period changes
  const handlePeriodChange = (newPeriod, setStartDate, setEndDate, setPeriod) => {
    const end = new Date();
    let start = new Date();

        if (newPeriod === '1D') start.setDate(end.getDate()); // Today only
        else if (newPeriod === '1W') start.setDate(end.getDate() - 6);
        else if (newPeriod === '1M') start.setDate(end.getDate() - 29);
        else start.setDate(end.getDate() - 6); // Default to 1W

        setStartDate(formatDate(start));
        setEndDate(formatDate(end));
        setPeriod(newPeriod);
  };
  



//   useEffect(() => {
    // In a real app, this would be an API call with the date range.
//     setLiveData(generateLiveProcessData());
//   }, [currentPlant, liveStartDate, liveEndDate]);

//   useEffect(() => {
//       const { totalPlantEnergy, renewable, nonRenewable } = liveData;
//       const totalEnergySource = renewable + nonRenewable;
//       const renewableMixPercent = totalEnergySource > 0 ? (renewable / totalEnergySource) * 100 : 0;
      
//       const metrics = generateEmissionMetrics(totalPlantEnergy, renewableMixPercent);
//       setEmissionData(metrics);
//       setDailyEmissionsData(generateDailyEmissions(emissionStartDate, emissionEndDate));
//   }, [liveData, currentPlant, emissionStartDate, emissionEndDate]);

//   useEffect(() => {
//     if (trendsPeriod === 'Custom') return;
//     handlePeriodChange(trendsPeriod, setTrendsStartDate, setTrendsEndDate, setTrendsPeriod);
//   }, [trendsPeriod]);

//   useEffect(() => {
//     setHistoricalData(generateHistoricalData(trendsStartDate, trendsEndDate, processesForSelection));
//     setDailyStackedData(generateDailyStackedData(trendsStartDate, trendsEndDate));
//   }, [trendsStartDate, trendsEndDate]);
  

  // useEffect(() => {
  //   let start, end;
  //   if (comparisonPeriod !== 'Custom') {
  //       end = new Date();
  //       start = new Date();
  //       if (comparisonPeriod === '1D') start.setDate(end.getDate());
  //       else if (comparisonPeriod === '1W') start.setDate(end.getDate() - 6);
  //       else if (comparisonPeriod === '1M') start.setDate(end.getDate() - 29);
  //       setComparisonStartDate(formatDate(start));
  //       setComparisonEndDate(formatDate(end));
  //   } else {
  //       start = new Date(comparisonStartDate);
  //       end = new Date(comparisonEndDate);
  //   }
  //   setPlantComparisonData(generateTimeSeriesComparisonData(selectedPlantsForComparison, formatDate(start), formatDate(end)));
  // }, [selectedPlantsForComparison, comparisonStartDate, comparisonEndDate, comparisonPeriod]);
  

//   const { totalPlantEnergy, renewable, nonRenewable } = liveData;
//   const totalEnergySource = renewable + nonRenewable;
//   const plantRenewablePercent = totalEnergySource > 0 ? ((renewable / totalEnergySource) * 100).toFixed(1) : 0;
//   const plantNonRenewablePercent = totalEnergySource > 0 ? ((nonRenewable / totalEnergySource) * 100).toFixed(1) : 0;

//   const renewableBreakdownData = [
//     { name: 'Wind', value: liveData.renewableWind, color: '#8884d8' },
//     { name: 'Solar', value: liveData.renewableSolar, color: '#82ca9d' },
//     { name: 'Hydro', value: liveData.renewableHydro, color: '#FFBB28' },
//     { name: 'Non-Renewable', value: liveData.nonRenewable, color: '#FF8042' },
//   ].filter(item => item.value > 0);

//   const processSustainabilityData = Object.keys(processEquipmentDB).map(proc => ({
//     name: proc,
//     renewable: liveData[proc.toLowerCase().replace(/ /g, '')]?.renewable || 0,
//     nonRenewable: liveData[proc.toLowerCase().replace(/ /g, '')]?.nonRenewable || 0,
//   }));

//   if (!emissionData || !liveData) {
//       return <div className="p-6 bg-gray-900 min-h-screen text-gray-200">Loading monitoring and emission data...</div>;
//   }

//   const { totalEmissions, processEmissions, emissionIntensity, benchmark } = emissionData;
  const subNavItems = [
      { name: 'Live', icon: Activity },
      { name: 'Trends', icon: BarChart3 },
      { name: 'Emissions', icon: Cloud },
      { name: 'Comparison', icon: Building2 },
  ];

//   const selectedProcessKey = processData.toLowerCase().replace(/ /g, '');
//   const selectedProcessData = liveData[selectedProcessKey];

//   let processRenewablePercent = 0;
//   let processNonRenewablePercent = 0;
//   if(selectedProcessData) {
//     const processTotalSource = selectedProcessData.renewable + selectedProcessData.nonRenewable;
//     processRenewablePercent = processTotalSource > 0 ? ((selectedProcessData.renewable / processTotalSource) * 100).toFixed(1) : 0;
//     processNonRenewablePercent = processTotalSource > 0 ? ((selectedProcessData.nonRenewable / processTotalSource) * 100).toFixed(1) : 0;
//   }

  

  return (
    <div className="p-6 bg-gray-900 min-h-screen text-gray-200">
        <div className="flex flex-col lg:flex-row space-y-6 lg:space-y-0 lg:space-x-6">
            {/* Side Navigation */}
            <aside className="lg:w-56 flex-shrink-0 bg-gray-800 p-4 rounded-xl self-start sticky top-24">
                <nav className="flex lg:flex-col space-x-2 lg:space-x-0 lg:space-y-2 overflow-x-auto">
                    {subNavItems.map(item => (
                        <button
                            key={item.name}
                            onClick={() => setActiveSubTab(item.name)}
                            className={`w-full flex items-center space-x-3 px-4 py-3 rounded-lg text-left transition-all duration-200 whitespace-nowrap ${
                                activeSubTab === item.name
                                ? 'bg-blue-600 text-white shadow-lg'
                                : 'text-gray-300 hover:bg-gray-700'
                            }`}
                        >
                            <item.icon className="h-5 w-5 flex-shrink-0" />
                            <span className="font-medium">{item.name}</span>
                        </button>
                    ))}
                </nav>
            </aside>

            {/* Main Content Area */}
            <main className="flex-grow">
                {activeSubTab === 'Live' && (
                  <>
                    <DateRangePicker 
                        startDate={liveStartDate}
                        endDate={liveEndDate}
                        period={livePeriod}
                        onStartDateChange={setLiveStartDate}
                        onEndDateChange={setLiveEndDate}
                        onPeriodChange={(p) => handlePeriodChange(p, setLiveStartDate, setLiveEndDate, setLivePeriod)}
                    />
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        {/*Overall Plant Status */}
                        <div className="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700 flex flex-col justify-between">
                            <div>
                                <h3 className="text-xl font-semibold text-white mb-2 flex items-center"><Zap className="mr-2 text-yellow-400" />Overall Plant Status</h3>
                                <p className="text-5xl font-bold text-white mb-2">{totalPlantEnergy.toFixed(2)} <span className="text-3xl text-gray-400">kWh</span></p>
                                <p className="text-sm text-gray-400 mb-4">Total Energy Consumption for selected period</p>
                            </div>
                            
                            <div className="space-y-4">
                                <div>
                                    <p className="text-lg font-semibold text-white mb-2">Energy Mix</p>
                                    <div className="w-full bg-gray-700 rounded-full h-4 mb-2">
                                        <div className="bg-green-500 h-4 rounded-full" style={{ width: `${((100*(renewableBreakdown.total)/totalPlantEnergy)).toFixed(2)}%` }}></div>
                                    </div>
                                    <div className="flex justify-between text-sm font-medium">
                                        <p className="text-green-400">Renewable: {(100*(renewableBreakdown.total)/totalPlantEnergy).toFixed(2)}% ({renewableBreakdown.total} kWh)</p>
                                        <p className="text-orange-400">Non-Renewable: {(100- (100*(renewableBreakdown.total)/totalPlantEnergy)).toFixed(2)}% ({(totalPlantEnergy-renewableBreakdown.total).toFixed(2)} kWh)</p>
                                    </div>
                                </div>  
                                <div>
                                    <p className="text-lg font-semibold text-white mb-2">Renewable Sources</p>
                                    <div className="space-y-2 text-gray-300">
                                        <div className="flex justify-between items-center"><span className="flex items-center"><Wind className="w-4 h-4 mr-2 text-blue-400"/>Wind</span> <span className="font-bold text-white">{renewableBreakdown.wind} kWh</span></div>
                                        <div className="flex justify-between items-center"><span className="flex items-center"><Lightbulb className="w-4 h-4 mr-2 text-yellow-400"/>Solar</span> <span className="font-bold text-white">{renewableBreakdown.solar} kWh</span></div>
                                        <div className="flex justify-between items-center"><span className="flex items-center"><Droplet className="w-4 h-4 mr-2 text-teal-400"/>Hydro</span> <span className="font-bold text-white">{renewableBreakdown.hydro} kWh</span></div>
                                    </div>
                                </div>
                                <div>
                                    <p className="text-lg font-semibold text-white mb-2">CO₂ Emission</p>
                                    <p className="text-2xl font-bold text-white">{processEmissions.toFixed(2)} <span className="text-lg text-gray-400">kg CO₂e</span></p>
                                </div>
                            </div>
                        </div>
                        
                        {/* Process Details */}
                        <div className="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700 flex flex-col">
                            <h3 className="text-xl font-semibold text-white mb-4">Process Details</h3>
                            <div className="mb-4">
                                <Dropdown
                                    label="Select Process"
                                    options={(processList.map(process => process.processName))}
                                    selected={selectedProcess?.processName || ''}
                                    onChange={(processName) => {
                                      const selected = processList.find(p => p.processName === processName);
                                      setSelectedProcess(selected);
                                    }}
                                    //     const selected = processData.find(proc => proc.processName === selectedName);
                                    //     setSelectedProcess(selected);
                                    //     setResult(null);

                                    //     if (selected?.processId) {
                                    //     try {
                                    //             const response = await fetch('https://energy-forecasting.onrender.com/api/processes', {
                                    //             method: 'POST',
                                    //             headers: {
                                    //                 'Content-Type': 'application/json',
                                    //             },
                                    //             body: JSON.stringify({
                                    //                 processId: selected.processId,
                                    //                 startDate: liveStartDate,
                                    //                 endDate: liveEndDate
                                    //             }),
                                    //         });

                                    //         if (!response.ok) {
                                    //             throw new Error(`HTTP error! status: ${response.status}`);
                                    //         }

                                    //         const data = await response.json();
                                    //         console.log('API Response:', data); // Debug log
                                    //         setResult(data);
                                    //     } catch (err) {
                                    //         console.error('Failed to fetch selected process data', err);
                                    //     }
                                    //     }
                                    //     if (selected?.renewableEnergyPercentage) {
                                    //     const [wind, solar, hydro] = selected.renewableEnergyPercentage;
                                    //     setRenewables({ wind, solar, hydro });
                                    //     } 
                                    //     const totalRenewablePercent = 
                                    //         parseFloat(renewables.wind.toFixed(2)) +
                                    //         parseFloat(renewables.solar.toFixed(2)) +
                                    //         parseFloat(renewables.hydro.toFixed(2));


                                    // }}
                                />
                            </div>
                            {/* process details */}
                                <>
                                    <div className="mb-4">
                                        <p className="text-3xl font-bold text-white">{processEnergy.toFixed(2)} <span className="text-xl text-gray-400">kWh</span></p>
                                        <p className="text-sm text-gray-400">
                                            Total Energy Consumption for {selectedProcess?.processName}
                                        </p>
                                    </div>
                            
                                    <div className="mb-4">
                                        

                                        <p className="text-md font-semibold text-white mb-1">Process Energy Mix</p>
                                        <div className="w-full bg-gray-700 rounded-full h-3">
                                            <div className="bg-green-500 h-3 rounded-full" style={{ width: `${totalRenewable.toFixed(2)}%` }}></div>
                                        </div>
                                        <div className="flex justify-between text-xs font-medium mt-1">
                                            <span className="text-green-400">Renewable: {totalRenewable.toFixed(2)}%</span>
                                            <span className="text-orange-400">Non-Renewable: {nonRenewable.toFixed(2)}%</span>
                                        </div>
                                    </div>
                                </>    
                                    <h4 className="text-lg font-semibold text-white mb-2">Equipment Load</h4>
                                          <div className="flex-grow overflow-y-auto pr-2" style={{ maxHeight: '200px' }}>
                                            <ul className="space-y-3">
                                              {equipmentData.map((equip, index) => (
                                                <li key={index} className="bg-gray-700/50 p-3 rounded-lg">
                                                  <div className="flex items-center justify-between mb-2">
                                                    <span className="font-semibold text-white">{equip.name}</span>
                                                    <span className="font-bold text-xl text-white">
                                                      {equip.energy.toFixed(2)} <span className="text-sm font-normal text-gray-400">kWh</span>
                                                    </span>
                                                  </div>
                                                  <div className="flex justify-between text-xs text-gray-300 px-1">
                                                    <span className="flex items-center">
                                                      <Bolt className="h-3 w-3 mr-1 text-yellow-500" />
                                                      {equip.voltage} V
                                                    </span>
                                                    <span className="flex items-center">
                                                      <Sigma className="h-3 w-3 mr-1 text-red-500" />
                                                      {equip.current} A
                                                    </span>
                                                    <span className="flex items-center">
                                                      <Thermometer className="h-3 w-3 mr-1 text-pink-400" />
                                                      {equip.temperature} °C
                                                    </span>
                                                    <span className="flex items-center">
                                                      <Droplet className="h-3 w-3 mr-1 text-blue-300" />
                                                      {equip.humidity}% RH
                                                    </span>
                                                  </div>
                                                </li>
                                              ))}
                                            </ul>
                                          </div>

                            
                            
                        </div>
                    </div>
                  </>
                )}

                {activeSubTab === 'Trends' && (
                    <div className="space-y-6">
                        <SectionCard title="Historical Trends">
                           <div className="flex flex-col sm:flex-row justify-between items-center mb-4 space-y-2 sm:space-y-0 sm:space-x-4">
                                <Dropdown
                                    label="Graph Type"
                                    options={['Energy Trends per Process', 'Daily Total Consumption by Process']}
                                    selected={graphView}
                                    onChange={setGraphView}
                                />
                                {graphView === 'Energy Trends per Process' && (
                                    <Dropdown
                                        label="Visible Lines"
                                        options={trendLineOptions}
                                        selected={visibleTrendLines}
                                        onChange={setVisibleTrendLines}
                                        isMulti={true}
                                    />
                                )}
                                <DateRangePicker 
                                    startDate={trendsStartDate}
                                    endDate={trendsEndDate}
                                    period={trendsPeriod}
                                    onStartDateChange={setTrendsStartDate}
                                    onEndDateChange={setTrendsEndDate}
                                    onPeriodChange={(p) => handlePeriodChange(p, setTrendsStartDate, setTrendsEndDate, setTrendsPeriod)}
                                />
                           </div>
                           {graphView === 'Energy Trends per Process' ? (
                                <ResponsiveContainer width="100%" height={350}>
                                    <LineChart data={historicalData} margin={{ top: 5, right: 30, left: 30, bottom: 25 }}>
                                    <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                                    <XAxis dataKey="date" dy={10} />
                                    <YAxis dx={-10} label={{ value: 'Energy (kWh)', angle: -90, position: 'insideLeft' }} />
                                    <Tooltip content={<CustomTooltip />} />
                                    <Legend />
                                    {visibleTrendLines.map((line, index) => (
                                        <Line key={line} type="monotone" dataKey={line} stroke={COLORS[index % COLORS.length]} dot={false} strokeWidth={line === 'Total Energy' ? 3 : 2}/>
                                    ))}
                                    </LineChart>
                                </ResponsiveContainer>
                           ) : (
                                <ResponsiveContainer width="100%" height={350}>
                                    <BarChart data={historicalData} margin={{ top: 5, right: 30, left: 30, bottom: 25 }}>
                                    <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                                    <XAxis dataKey="date" dy={10} />
                                    <YAxis dx={-10} label={{ value: 'Energy (kWh)', angle: -90, position: 'insideLeft' }} />
                                    <Tooltip content={<CustomTooltip />} />
                                    <Legend />
                                    {processList.map((proc, index) => (
                                      <Bar
                                        key={proc.processId}
                                        dataKey={proc.processName}
                                        stackId="a"
                                        fill={COLORS[index % COLORS.length]}
                                      />
                                    ))}
                                    </BarChart>
                                </ResponsiveContainer>
                           )}
                        </SectionCard>
                        <SectionCard title="Monthly Consumption Summary (kWh)">
                          <div className="overflow-x-auto">
                            <table className="min-w-full bg-gray-700 rounded-lg">
                              <thead>
                                <tr className="bg-gray-600 text-left text-sm font-medium text-gray-300 uppercase tracking-wider">
                                  <th className="px-4 py-3 rounded-tl-lg">Month</th>
                                  {processesForSelection.map(system => (<th key={system} className="px-4 py-3">{system}</th>))}
                                  <th className="px-4 py-3 rounded-tr-lg">Total Energy (kWh)</th>
                                </tr>
                              </thead>
                              <tbody className="divide-y divide-gray-600">
                                {monthlySummary.map((data, index) => (
                                  <tr key={index} className="hover:bg-gray-600 transition-colors duration-200">
                                    <td className="px-4 py-3 whitespace-nowrap text-gray-300">{data.month}</td>
                                    {processesForSelection.map(system => {
                                      const value = data[system];
                                      return ( <td key={system} className="px-4 py-3 whitespace-nowrap">{value.toFixed(2)}</td>);
                                    })}
                                    <td className="px-4 py-3 whitespace-nowrap font-bold text-white">{data['Total Energy (kWh)'].toFixed(2)}</td>
                                  </tr>
                                ))}
                              </tbody>
                            </table>
                          </div>
                        </SectionCard>
                    </div>
                )}

                {activeSubTab === 'Emissions' && (
                    <div className="space-y-6">
                      <DateRangePicker 
                          startDate={emissionStartDate}
                          endDate={emissionEndDate}
                          period={emissionPeriod}
                          onStartDateChange={setEmissionStartDate}
                          onEndDateChange={setEmissionEndDate}
                          onPeriodChange={(p) => handlePeriodChange(p, setEmissionStartDate, setEmissionEndDate, setEmissionPeriod)}
                      />
                      <SectionCard title="CO₂ Emissions Analysis">
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                            <StatCard title="Total Plant Emissions (CO₂e)" value={totalEmissions} unit=" kg" color="border-green-600" icon={Cloud} />
                            <StatCard title="Emission Intensity" value={(totalEmissions/totalPlantEnergy).toFixed(2)} unit=" kg CO₂e/kWh" color="border-green-600" icon={Zap} />
                        </div>
                        {/* <p className="text-sm text-gray-400 mb-6 -mt-4 italic">Note: Benchmark target: {benchmark} kg CO₂e/kWh.</p> */}
                        <h4 className="text-lg font-semibold text-white mt-6 mb-2">Daily CO₂ Emissions Trend (kg CO₂e)</h4>
                          <ResponsiveContainer width="100%" height={300}>
                            <LineChart data={historicalEmissions} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
                              <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                              <XAxis dataKey="date" stroke="#9CA3AF" />
                              <YAxis stroke="#9CA3AF" />
                              <Tooltip content={<CustomTooltip unit="kg CO₂e" />} />
                              <Legend wrapperStyle={{ color: '#9CA3AF' }} />
                              <Line
                                type="monotone"
                                dataKey="Total Emissions (Kg)"
                                stroke="#82ca9d"
                                name="Total Emissions"
                                dot={false}
                              />
                            </LineChart>
                          </ResponsiveContainer>
                        <h4 className="text-lg font-semibold text-white mb-2">Process-Wise Emissions (kg CO₂e)</h4>
                          <ResponsiveContainer width="100%" height={300}>
                            <BarChart data={historicalEmissions} margin={{ top: 10, right: 30, left: 20, bottom: 5 }}>
                              <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                              <XAxis dataKey="date" stroke="#9CA3AF" />
                              <YAxis stroke="#9CA3AF" />
                              <Tooltip content={<CustomTooltip unit="kg CO₂e" />} />
                              <Legend />
                              {processList.map((proc, index) => (
                                <Bar
                                  key={proc.processId}
                                  dataKey={proc.processName}
                                  stackId="a"
                                  fill={COLORS[index % COLORS.length]}
                                />
                              ))}
                            </BarChart>
                          </ResponsiveContainer>

                        

                      </SectionCard>
                      <SectionCard title="Overall Renewable vs Non-Renewable Energy Mix">
                            <ResponsiveContainer width="100%" height={400}>
                              <PieChart>
                                <Pie
                                  data={renewableBreakdownData}
                                  cx="50%"
                                  cy="50%"
                                  labelLine={true}
                                  label={({ name, percent, value }) =>
                                    `${name}: ${value.toFixed(0)} kWh (${(percent * 100).toFixed(0)}%)`
                                  }
                                  outerRadius={150}
                                  fill="#8884d8"
                                  dataKey="value"
                                >
                                  {renewableBreakdownData.map((entry, index) => (
                                    <Cell key={`cell-${index}`} fill={entry.color} />
                                  ))}
                                </Pie>
                                <Tooltip formatter={(value, name) => [`${value.toFixed(2)} kWh`, name]} />
                                <Legend />
                              </PieChart>
                            </ResponsiveContainer>
                          </SectionCard>

                        <SectionCard title="Process-wise Sustainability Analysis">
                          <ResponsiveContainer width="100%" height={300}>
                            <BarChart 
                              data={processSustainabilityData} 
                              layout="vertical" 
                              margin={{ top: 5, right: 30, left: 30, bottom: 5 }}
                            >
                              <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                              <XAxis type="number" unit="%" />
                              <YAxis type="category" dataKey="name" width={150} />
                              <Tooltip content={<CustomTooltip unit="%" />} />
                              <Legend />
                              <Bar dataKey="wind" stackId="a" fill="#87CEEB" name="Wind" />
                              <Bar dataKey="solar" stackId="a" fill="#FFD700" name="Solar" />
                              <Bar dataKey="hydro" stackId="a" fill="#4682B4" name="Hydro" />
                              <Bar dataKey="nonRenewable" stackId="a" fill="#FF8042" name="Non-Renewable" />
                            </BarChart>
                          </ResponsiveContainer>
                        </SectionCard>

                    </div>
                )}

                {activeSubTab === 'Comparison' && (
                  <div className="space-y-6">
                      <SectionCard title="Plants Comparison">
                        <div className="flex flex-col space-y-4 mb-4">
                          <Dropdown label="Plants for Comparison" options={plants} selected={selectedPlantsForComparison} onChange={setSelectedPlantsForComparison} isMulti={true} />
                          <div className="flex flex-wrap gap-2 items-center">
                            <label className="text-gray-300 whitespace-nowrap">Time Duration:</label>
                            <input type="date" value={comparisonStartDate} onChange={(e) => { setComparisonStartDate(e.target.value); setComparisonPeriod('Custom'); }} className="px-3 py-2 bg-gray-700 text-white border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" />
                            <span className="text-gray-300">-</span>
                            <input type="date" value={comparisonEndDate} onChange={(e) => { setComparisonEndDate(e.target.value); setComparisonPeriod('Custom'); }} className="px-3 py-2 bg-gray-700 text-white border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" />
                            <div className="flex space-x-2">
                              {['1D', '1W', '1M'].map(period => (
                                <button key={period} onClick={() => setComparisonPeriod(period)} className={`px-4 py-2 rounded-lg font-medium transition-all duration-200 ${comparisonPeriod === period ? 'bg-blue-600 text-white shadow-md' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}>{period}</button>
                              ))}
                            </div>
                          </div>
                        </div>

                        <h4 className="text-lg font-semibold text-white mb-2">Total Energy Consumption Comparison</h4>
                        <ResponsiveContainer width="100%" height={250}>
                          <LineChart data={plantComparisonData}>
                            <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                            <XAxis dataKey="date" />
                            <YAxis />
                            <Tooltip content={<CustomTooltip />} />
                            <Legend />
                            {selectedPlantsForComparison.map((plant, index) => (
                              <Line key={plant} type="monotone" dataKey={`${plant}_totalEnergy`} name={plant} stroke={COLORS[index % COLORS.length]} dot={false} />
                            ))}
                          </LineChart>
                        </ResponsiveContainer>

                        <h4 className="text-lg font-semibold text-white mt-6 mb-2">Process-wise Energy Consumption</h4>
                        <Dropdown label="Select Process" options={processesForSelectionn} selected={comparisonProcess} onChange={setComparisonProcess} />
                        <ResponsiveContainer width="100%" height={250}>
                          <LineChart data={plantComparisonData}>
                            <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                            <XAxis dataKey="date" />
                            <YAxis />
                            <Tooltip content={<CustomTooltip />} />
                            <Legend />
                            {selectedPlantsForComparison.map((plant, index) => (
                              <Line key={plant} type="monotone" dataKey={`${plant}_${comparisonProcess}`} name={plant} stroke={COLORS[index % COLORS.length]} dot={false} />
                            ))}
                          </LineChart>
                        </ResponsiveContainer>            
                        <h4 className="text-lg font-semibold text-white mb-2">Total CO₂ Emissions Comparison</h4>
                        <ResponsiveContainer width="100%" height={250}>
                          <LineChart data={plantComparisonData}>
                            <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                            <XAxis dataKey="date" />
                            <YAxis />
                            <Tooltip content={<CustomTooltip />} />
                            <Legend />
                            {selectedPlantsForComparison.map((plant, index) => (
                              <Line key={plant} type="monotone" dataKey={`${plant}_totalCO2`} name={`${plant} CO₂`} stroke={COLORS[(index + 1) % COLORS.length]} dot={false} />
                            ))}
                          </LineChart>
                        </ResponsiveContainer>
                        <h4 className="text-lg font-semibold text-white mt-6 mb-2">Process-wise CO₂ Emissions</h4>
                        <ResponsiveContainer width="100%" height={250}>
                          <LineChart data={plantComparisonData}>
                            <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                            <XAxis dataKey="date" />
                            <YAxis />
                            <Tooltip content={<CustomTooltip />} />
                            <Legend />
                            {selectedPlantsForComparison.map((plant, index) => (
                              <Line key={plant} type="monotone" dataKey={`${plant}_${comparisonProcess}_CO2`} name={`${plant} ${comparisonProcess} CO₂`} stroke={COLORS[(index + 2) % COLORS.length]} dot={false} />
                            ))}
                          </LineChart>
                        </ResponsiveContainer>
                        

                        {/* <h4 className="text-lg font-semibold text-white mt-6 mb-2">Renewable vs Non-Renewable Comparison</h4>
                        <Dropdown label="Select Energy Type" options={['Renewable', 'Non-Renewable']} selected={comparisonEnergyType} onChange={setComparisonEnergyType}/>
                        <ResponsiveContainer width="100%" height={250}>
                           <LineChart data={plantComparisonData}>
                                <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                                <XAxis dataKey="date" />
                                <YAxis />
                                <Tooltip content={<CustomTooltip />} />
                                <Legend />
                                {selectedPlantsForComparison.map((plant, index) => (
                                    <Line key={plant} type="monotone" dataKey={`${plant}_${comparisonEnergyType.toLowerCase()}`} name={plant} stroke={COLORS[index % COLORS.length]} dot={false} />
                                ))}
                            </LineChart>
                        </ResponsiveContainer> */}
                    </SectionCard>
                  </div>
                )}
               
            </main>
        </div>
    </div>
  );
};


const App = () => {
  const [currentPlant, setCurrentPlant] = useState('Select Plant');

  return (
    <div className="font-sans antialiased bg-gray-950">
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
        body {
          font-family: 'Inter', sans-serif;
        }
        .scrollbar-thin {
          scrollbar-width: thin;
          scrollbar-color: #4a5568 #2d3748;
        }
        .scrollbar-thin::-webkit-scrollbar {
          width: 8px;
          height: 8px;
        }
        .scrollbar-thin::-webkit-scrollbar-thumb {
          background-color: #4a5568;
          border-radius: 10px;
          border: 2px solid #2d3748;
        }
        .scrollbar-thin::-webkit-scrollbar-track {
          background-color: #2d3748;
          border-radius: 10px;
        }
      `}</style>
      <Header 
        currentPlant={currentPlant}
        setCurrentPlant={setCurrentPlant} 
      />
      <main>
        <MonitoringTab
          currentPlant={currentPlant}
        />
      </main>
    </div>
  );
};

export default App;
